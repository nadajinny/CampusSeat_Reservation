# 🗂 상태 & 스토리지 정책

로그인 상태 유지와 예약 플로우 간 컨텍스트 전달은 모두 **브라우저 `sessionStorage`** 에 의존합니다.  
각 키가 언제 생성/갱신/삭제되는지 명확히 이해하면, 페이지 이동이 잦은 구조에서도 일관된 UX를 제공할 수 있습니다.

---

## 1. 저장 매체 선택 이유

- **sessionStorage**  
  탭 단위로 격리되고 브라우저를 닫거나 새 탭을 열면 초기화되므로, JWT/학번 같은 민감 정보가 다른 창으로 새어 나가지 않습니다.  
  자동 만료 덕분에 로그아웃 누락으로 인한 보안 사고도 줄어듭니다.

- **localStorage (사용하지 않음)**  
  여러 탭에서 공유되므로, 동일 학번이 다른 계정으로 로그인할 때 상태 충돌이 발생합니다.  
  의도적으로 사용하지 않으며 새로 기능을 추가할 때에도 sessionStorage로 통일합니다.

---

## 2. 키 목록 및 라이프사이클

| 키 | 생성 시점 | 사용 화면 | 삭제 시점 | 비고 |
| --- | --- | --- | --- | --- |
| `studentId` | `login.html`에서 로그인 성공 시 (`ApiClient.login`) | 모든 페이지(헤더 표시, 내 예약 필터, API 호출) | 로그아웃 버튼 클릭 또는 세션 만료 | 문자열로 저장. 학번을 UI에 노출할 때도 이 값을 사용합니다. |
| `accessToken` | `login.html`에서 로그인 성공 시 | `js/api-client.js` → Authorization 헤더 자동 구성 | 로그아웃/세션 만료 | 서버가 발급한 토큰 문자열. 직접 읽어서 사용하지 말고 `ApiClient`를 통해 접근합니다. |
| `pendingReservation` | `search-availability.html`에서 시간/유형 선택 후 다음 단계 버튼 클릭 시 | `meeting-room-reservation.html`, `seat-reservation.html` | 예약 완료, 취소, 혹은 오류 발생 시 즉시 삭제 | JSON 문자열. `{ type, date, slots, roomId? }` 구조를 고정 유지합니다. |

라이프사이클을 준수하지 않으면 다음 단계 화면이 컨텍스트를 찾지 못해 자동으로 검색 페이지로 되돌아가게 됩니다.

---

## 3. 화면별 상태 사용 패턴

1. **로그인 → 대시보드**
   - `login.html`이 `studentId`와 `accessToken`을 저장.
   - `dashboard.html` 및 이후 페이지는 DOMContentLoaded 단계에서 두 키가 존재하는지 확인 후, 없으면 즉시 로그인 화면으로 리다이렉트합니다.

2. **예약 검색 → 회의실/열람실 예약**
   - 사용자가 시설 유형과 날짜, 시간대를 확정하면 `pendingReservation`에 JSON 문자열로 직렬화하여 저장.
   - 다음 페이지는 `pendingReservation`을 파싱해 유효성을 검증한 뒤 UI에 바인딩합니다. 실패하면 안내 메시지와 함께 검색 페이지로 돌아가도록 `js/app.js`가 처리합니다.

3. **내 예약 관리**
   - `studentId`와 `accessToken`을 읽어 API를 호출합니다.
   - 페이지 내에서 추가 스토리지 키를 사용하지 않으며, 필터 상태는 DOM 요소 값을 그대로 사용합니다.

---

## 4. 보안 및 안정성 수칙

- **민감 데이터 최소화**: 토큰 외의 개인정보(이름, 전화번호 등)는 저장하지 않습니다. API 응답에 포함되더라도 필요 시마다 메모리 변수로만 사용합니다.
- **동일 탭 유지 권장**: sessionStorage는 탭마다 별도이므로, 사용자에게 “같은 탭에서 로그인 후 예약을 진행”하라고 안내합니다.
- **오류 처리 시 초기화**: 예약 중 오류가 발생하면 `pendingReservation`을 즉시 삭제해 재시도 시 얽힌 상태가 남지 않도록 합니다.
- **JSON 파싱 예외 처리**: `pendingReservation`을 파싱할 때 try/catch로 감싸 잘못된 값이 들어와도 앱이 중단되지 않도록 합니다 (`js/app.js` 참고).

이 원칙을 따르면 페이지를 새로고침하거나 뒤로 가더라도 예측 가능한 상태가 유지되며, 사용자는 항상 올바른 화면으로 안내됩니다.
